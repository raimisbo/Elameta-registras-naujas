{# templates/snippets/columns_dnd_shared.html #}
<style>
  .th-draggable { user-select: none; cursor: grab; transition: all .2s; }
  .th-dragging { opacity: .7; cursor: grabbing; box-shadow: 0 0 12px rgba(0,0,0,.25); background: #fff; }
  .th-drop-target { outline: 2px dashed #999; outline-offset: -3px; }
</style>
<script>
(function () {
  const TABLE_ID = "{{ table_id }}";
  const PAGE_KEY = "{{ page_key }}";
  const STORE_KEY = "dnd-order:" + PAGE_KEY;

  const table = document.getElementById(TABLE_ID);
  if (!table) return;

  const headRow = table.querySelector("thead tr.headers");
  if (!headRow) return;

  const filterRow = table.querySelector("thead tr.filters");
  const colgroup = table.querySelector("colgroup");
  const body = table.querySelector("tbody");

  // visus header th padarom drag'inamus
  const headerThs = Array.from(headRow.children);
  headerThs.forEach(th => th.classList.add("th-draggable"));

  let dragSrc = null;

  function getStoredOrder() {
    try {
      return JSON.parse(localStorage.getItem(STORE_KEY) || "[]");
    } catch (e) {
      return [];
    }
  }

  function saveOrder(order) {
    localStorage.setItem(STORE_KEY, JSON.stringify(order));
  }

  function currentOrderFromDOM() {
    return Array.from(headRow.children)
      .map(th => th.dataset.key)
      .filter(Boolean);
  }

  /**
   * Perstato HEADER, FILTRŲ EILUTĘ, COLGROUP ir TBODY pagal duotą stulpelių tvarką
   */
  function applyOrder(order) {
    if (!order || !order.length) return;

    // 1) HEADER
    const thMap = {};
    Array.from(headRow.children).forEach(th => {
      const key = th.dataset.key;
      if (key) thMap[key] = th;
    });
    order.forEach(key => {
      const th = thMap[key];
      if (th) headRow.appendChild(th);
    });

    // 2) FILTRŲ EILUTĖ
    if (filterRow) {
      const fMap = {};
      Array.from(filterRow.children).forEach(th => {
        const key = th.dataset.key;
        if (key) fMap[key] = th;
      });
      order.forEach(key => {
        const th = fMap[key];
        if (th) filterRow.appendChild(th);
      });
    }

    // 3) COLGROUP
    if (colgroup) {
      const cMap = {};
      Array.from(colgroup.children).forEach(col => {
        const key = col.dataset.key;
        if (key) cMap[key] = col;
      });
      order.forEach(key => {
        const col = cMap[key];
        if (col) colgroup.appendChild(col);
      });
    }

    // 4) TBODY – čia buvo tavo problema
    if (body) {
      const rows = Array.from(body.querySelectorAll("tr"));
      rows.forEach(tr => {
        const tds = Array.from(tr.children);
        // susikuriam žemėlapį pagal data-key
        const tdMap = {};
        const noKey = []; // veiksmų stulpelis ar panašūs
        tds.forEach(td => {
          const key = td.dataset.key;
          if (key) {
            tdMap[key] = td;
          } else {
            noKey.push(td);
          }
        });

        // dabar pagal orderį sudedam iš naujo
        order.forEach(key => {
          const td = tdMap[key];
          if (td) tr.appendChild(td);
        });

        // gale prikabinam tuos, kurie be data-key (pvz. "Veiksmai")
        noKey.forEach(td => tr.appendChild(td));
      });
    }

    // kad mūsų sticky pirmas matomas vėl susiskaičiuotų
    if (window.applySticky) {
      try { window.applySticky(); } catch (e) {}
    }
  }

  // drag įvykiai
  headerThs.forEach(th => {
    th.draggable = true;

    th.addEventListener("dragstart", e => {
      dragSrc = th;
      th.classList.add("th-dragging");
      e.dataTransfer.effectAllowed = "move";
    });

    th.addEventListener("dragend", () => {
      dragSrc = null;
      headerThs.forEach(h => h.classList.remove("th-dragging", "th-drop-target"));
    });

    th.addEventListener("dragover", e => {
      if (!dragSrc || dragSrc === th) return;
      e.preventDefault();
      th.classList.add("th-drop-target");
      e.dataTransfer.dropEffect = "move";
    });

    th.addEventListener("dragleave", () => {
      th.classList.remove("th-drop-target");
    });

    th.addEventListener("drop", e => {
      e.stopPropagation();
      if (!dragSrc || dragSrc === th) return;
      th.classList.remove("th-drop-target");

      const cells = Array.from(headRow.children);
      const srcIndex = cells.indexOf(dragSrc);
      const targetIndex = cells.indexOf(th);

      if (srcIndex < targetIndex) {
        headRow.insertBefore(dragSrc, th.nextSibling);
      } else {
        headRow.insertBefore(dragSrc, th);
      }

      // iš DOM'o pasiimam naują tvarką ir pritaikom viskam
      const newOrder = currentOrderFromDOM();
      applyOrder(newOrder);
      saveOrder(newOrder);

      return false;
    });
  });

  // pradinė tvarka iš localStorage
  const storedOrder = getStoredOrder();
  if (storedOrder && storedOrder.length) {
    applyOrder(storedOrder);
  } else {
    // jei dar nieko nesaugojom – saugom dabartinę
    saveOrder(currentOrderFromDOM());
  }

  // mygtukas "↺ Atstatyti tvarką" – jei yra
  const resetBtn = document.getElementById("cols-reset-order");
  if (resetBtn) {
    resetBtn.addEventListener("click", () => {
      localStorage.removeItem(STORE_KEY);
      // paprasčiausia – perkrauti
      location.reload();
    });
  }

  // kai tavo AJAX perpiešia <tbody> (mes darėm dispatch("tbody:reloaded"))
  // reikia perstumti ir naujai atėjusias eiles
  document.addEventListener("tbody:reloaded", () => {
    const ord = getStoredOrder();
    if (ord && ord.length) applyOrder(ord);
  });
})();
</script>
