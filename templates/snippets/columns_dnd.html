<style>
  .th-dragging {
    opacity: .6;
  }

  .th-drop-target {
    outline: 2px dashed #888;
    outline-offset: -4px;
  }
</style>

<script>
(function(){
  const table = document.querySelector('#results-table');
  if (!table || !table.tHead || !table.tBodies.length) return;

  const colgroup = table.querySelector('colgroup');
  const KEY = 'colOrder_v2:' + (table.id || 'results-table') + ':' + (location.pathname || 'default');

  function colKey(th, idx) {
    const k = th.getAttribute('data-col');
    return (k && k.trim()) ? k.trim() : ('col' + idx);
  }

  function saveOrder() {
    const keys = Array.from(table.tHead.rows[0].cells).map(colKey);
    try {
      localStorage.setItem(KEY, JSON.stringify(keys));
    } catch (_) {}
  }

  function applySavedOrder() {
    let saved;
    try {
      saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    } catch (_) {
      saved = [];
    }
    if (!saved || !saved.length) return;

    const ths = Array.from(table.tHead.rows[0].cells);
    const curKeys = ths.map(colKey);
    const order = [];

    // Reikia atitikti tik tas, kurios egzistuoja
    saved.forEach(sk => {
      const i = curKeys.indexOf(sk);
      if (i > -1) order.push(i);
    });
    // Pridedam naujus, jei jų dar nebuvo
    curKeys.forEach((k, i) => {
      if (saved.indexOf(k) === -1) order.push(i);
    });

    reorder(order);
  }

  function reorder(order) {
    const headRow = table.tHead.rows[0];
    const ths = Array.from(headRow.cells);
    if (!ths.length || ths.some(c => c.colSpan !== 1)) return;

    const keysByIndex = ths.map(colKey);

    // HEAD
    const fragHead = document.createDocumentFragment();
    order.forEach(i => fragHead.appendChild(ths[i]));
    headRow.appendChild(fragHead);

    // BODY
    Array.from(table.tBodies).forEach(tbody => {
      Array.from(tbody.rows).forEach(tr => {
        const tds = Array.from(tr.cells);
        if (tds.length !== keysByIndex.length) return;
        const frag = document.createDocumentFragment();
        order.forEach(i => frag.appendChild(tds[i]));
        tr.appendChild(frag);
      });
    });

    // COLGROUP
    if (colgroup && colgroup.children.length) {
      const colsByKey = {};
      Array.from(colgroup.children).forEach(c => {
        const k = c.getAttribute('data-col');
        if (k) colsByKey[k] = c;
      });

      const fragCol = document.createDocumentFragment();
      order.forEach(i => {
        const k = keysByIndex[i];
        const col = colsByKey[k];
        if (col) fragCol.appendChild(col);
      });
      colgroup.appendChild(fragCol);
    }

    window.dispatchEvent(new Event('table:order-changed'));
  }

  // Drag & Drop init
  Array.from(table.tHead.rows[0].cells).forEach((th, index) => {
    if (th.colSpan !== 1) return;
    th.setAttribute('draggable', 'true');

    th.addEventListener('dragstart', e => {
      th.classList.add('th-dragging');
      th.dataset.dragIndex = Array.from(th.parentNode.children).indexOf(th);
      try {
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', 'col');
      } catch (_) {}
    });

    th.addEventListener('dragend', () => {
      th.classList.remove('th-dragging');
      Array.from(table.tHead.rows[0].cells).forEach(x => x.classList.remove('th-drop-target'));
      delete th.dataset.dragIndex;
    });

    th.addEventListener('dragover', e => {
      e.preventDefault();
      th.classList.add('th-drop-target');
      try {
        e.dataTransfer.dropEffect = 'move';
      } catch (_) {}
    });

    th.addEventListener('dragleave', () => {
      th.classList.remove('th-drop-target');
    });

    th.addEventListener('drop', e => {
      e.preventDefault();
      th.classList.remove('th-drop-target');
      const drag = document.querySelector('.th-dragging');
      const from = drag ? parseInt(drag.dataset.dragIndex || '-1', 10) : -1;
      const to = Array.from(th.parentNode.children).indexOf(th);
      if (from < 0 || to < 0 || from === to) return;

      const len = table.tHead.rows[0].cells.length;
      const order = Array.from({ length: len }, (_, i) => i);
      const item = order.splice(from, 1)[0];
      order.splice(to, 0, item);

      reorder(order);
      saveOrder();
    });
  });

  applySavedOrder();

  // Patogus reset per naršyklės konsolę
  window.resetTableColumnOrder = function(){
    localStorage.removeItem(KEY);
    location.reload();
  };
})();
</script>
