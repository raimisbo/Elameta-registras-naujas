{% load static %}
<!doctype html>
<html lang="lt">
<head>
  <meta charset="utf-8">
  <title>3D peržiūra – {{ brezinys.pavadinimas|default:brezinys.filename }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    html, body { height: 100%; margin: 0; background: #0b1220; color: #e5e7eb; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif; }

    .topbar {
      height: 52px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 12px;
      background: #111827;
      border-bottom: 1px solid rgba(255,255,255,.08);
      box-sizing: border-box;
      gap: 12px;
    }
    .topbar .left, .topbar .right { display:flex; gap:10px; align-items:center; }
    .topbar .title { min-width: 0; text-align: center; flex: 1; }
    .topbar .title .main { font-weight: 600; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .topbar .title .sub  { font-size: 12px; opacity: .8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .ui-btn, .ui-link {
      color: #93c5fd;
      text-decoration: none;
      font-size: 13px;
      border: 1px solid rgba(147,197,253,.35);
      padding: 6px 10px;
      border-radius: 6px;
      white-space: nowrap;
      background: transparent;
      cursor: pointer;
      user-select: none;
    }
    .ui-btn:hover, .ui-link:hover { background: rgba(147,197,253,.08); }
    .ui-btn.is-on {
      background: rgba(147,197,253,.10);
      border-color: rgba(147,197,253,.60);
    }

    #viewer {
      height: calc(100vh - 52px);
      width: 100%;
    }

    #status {
      position: fixed;
      left: 12px;
      bottom: 12px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      max-width: min(820px, calc(100vw - 24px));
      display: none;
      white-space: pre-wrap;
      z-index: 9999;
    }

    /* Overlay (NE viduje #viewer, kad O3DV jo neištrintų) */
    #measureOverlay {
      position: fixed;
      left: 0;
      top: 52px;
      width: 100vw;
      height: calc(100vh - 52px);
      pointer-events: none;
      display: none;
      z-index: 9000;
    }
    #measureSvg {
      position:absolute;
      left:0; top:0;
      width:100%;
      height:100%;
    }
    .mpt {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: rgba(147,197,253,.90);
      border: 2px solid rgba(255,255,255,.80);
      box-shadow: 0 0 0 2px rgba(0,0,0,.25);
      transform: translate(-9999px, -9999px);
    }
    .mlabel {
      position:absolute;
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.18);
      color: #e5e7eb;
      transform: translate(-9999px, -9999px);
      white-space: nowrap;
    }
  </style>

  <script src="{% static 'pozicijos/js/o3dv.min.js' %}"></script>
  <script>
    const STEP_MODEL_URL = "{{ brezinys.failas.url|escapejs }}";

    // Jei reikia vienetų konversijos:
    // mm -> m: 0.001 ir "m"
    const MEASURE_SCALE = 1.0;
    const MEASURE_UNIT  = "mm";

    function setStatus(msg, show = true) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.style.display = show ? 'block' : 'none';
    }

    function fmt(n, d=3) {
      if (typeof n !== 'number' || !isFinite(n)) return String(n);
      return n.toFixed(d);
    }

    function isThreeCamera(obj) {
      if (!obj) return false;
      // Tipiškai THREE.Camera turi projectionMatrix ir matrixWorldInverse
      return !!(obj.projectionMatrix && obj.matrixWorldInverse) || !!(obj.isCamera || obj.isPerspectiveCamera || obj.isOrthographicCamera);
    }

    window.addEventListener('load', () => {
      const OVNS = window.OV || (typeof OV !== 'undefined' ? OV : null);
      if (!OVNS) { setStatus("O3DV nepasiekiamas: nerastas global OV."); return; }
      if (!OVNS.EmbeddedViewer) { setStatus("O3DV įkeltas, bet nerastas OV.EmbeddedViewer."); return; }
      if (!STEP_MODEL_URL) { setStatus("Tuščias STEP_MODEL_URL (brezinys.failas.url)."); return; }

      const host = document.getElementById('viewer');
      const overlay = document.getElementById('measureOverlay');
      const p1el = document.getElementById('mpt1');
      const p2el = document.getElementById('mpt2');
      const line = document.getElementById('mline');
      const label = document.getElementById('mlabel');

      let embedded = null;
      let innerViewer = null;
      let navigation = null;
      let isLoaded = false;

      // Measure state
      let measureOn = false;
      let P1v = null; // THREE.Vector3
      let P2v = null; // THREE.Vector3
      // fallback screen coords (kad NIEKADA nedingtų, net jei camera nerandam)
      let S1f = null; // {x,y,visible}
      let S2f = null;

      let rafId = null;

      function showOverlay(on) {
        overlay.style.display = on ? 'block' : 'none';
      }

      function setMarker(el, s) {
        if (!s || !s.visible) {
          el.style.transform = 'translate(-9999px, -9999px)';
          return;
        }
        el.style.transform = `translate(${s.x}px, ${s.y}px) translate(-5px, -5px)`;
      }

      function setLine(a, b) {
        if (!a || !b || !a.visible || !b.visible) {
          line.setAttribute('x1', '-9999'); line.setAttribute('y1', '-9999');
          line.setAttribute('x2', '-9999'); line.setAttribute('y2', '-9999');
          return;
        }
        line.setAttribute('x1', String(a.x));
        line.setAttribute('y1', String(a.y));
        line.setAttribute('x2', String(b.x));
        line.setAttribute('y2', String(b.y));
      }

      function setLabel(s, text) {
        if (!s || !s.visible) {
          label.style.transform = 'translate(-9999px, -9999px)';
          label.textContent = '';
          return;
        }
        label.textContent = text;
        label.style.transform = `translate(${s.x}px, ${s.y}px) translate(-50%, -120%)`;
      }

      function clearMeasure(keepMode=false) {
        P1v = null; P2v = null;
        S1f = null; S2f = null;
        setMarker(p1el, null);
        setMarker(p2el, null);
        setLine(null, null);
        setLabel(null, "");

        const btnClear = document.getElementById('btnClear');
        btnClear.style.display = (measureOn ? 'inline-block' : 'none');

        if (keepMode && measureOn) {
          setStatus("Matavimas: spausk 1 tašką ant modelio, tada 2 tašką.\nESC – išjungti. \"Išvalyti\" – nuvalyti.");
        } else if (!measureOn) {
          setStatus("", false);
        }
      }

      function setMeasureMode(on) {
        measureOn = on;

        const btn = document.getElementById('btnMeasure');
        const btnClear = document.getElementById('btnClear');

        btn.classList.toggle('is-on', measureOn);
        btnClear.style.display = measureOn ? 'inline-block' : 'none';

        if (measureOn) {
          showOverlay(true);
          clearMeasure(true);
          startTick();
        } else {
          showOverlay(false);
          clearMeasure(false);
          stopTick();
        }
      }

      function getThreeCam() {
        if (!innerViewer) return null;

        // bandome kelis kandidatus
        const cands = [];
        try {
          if (typeof innerViewer.GetCamera === "function") cands.push(innerViewer.GetCamera());
        } catch (e) {}
        cands.push(innerViewer.camera);
        cands.push(innerViewer.renderer && innerViewer.renderer.camera);
        cands.push(innerViewer.renderer && innerViewer.renderer.threeCamera);

        for (const c of cands) {
          if (!c) continue;
          if (isThreeCamera(c)) return c;

          // wrapper'iai (pvz. { camera: THREE.Camera } arba { threeCamera: ... })
          if (c.camera && isThreeCamera(c.camera)) return c.camera;
          if (c.threeCamera && isThreeCamera(c.threeCamera)) return c.threeCamera;

          // metodai (retai, bet būna)
          try {
            if (typeof c.GetThreeCamera === "function") {
              const tc = c.GetThreeCamera();
              if (isThreeCamera(tc)) return tc;
            }
          } catch (e) {}
        }
        return null;
      }

      function projectToOverlay(vec3, cam) {
        if (!vec3 || !cam) return null;

        const w = overlay.clientWidth;
        const h = overlay.clientHeight;
        if (!w || !h) return null;

        if (typeof vec3.clone !== "function" || typeof vec3.project !== "function") return null;

        const v = vec3.clone().project(cam); // NDC
        const x = (v.x * 0.5 + 0.5) * w;
        const y = (-v.y * 0.5 + 0.5) * h;

        // mažiau agresyvus visible (kad “neužmuštų” vaizdo)
        const visible =
          isFinite(x) && isFinite(y) &&
          x >= -100 && x <= (w + 100) &&
          y >= -100 && y <= (h + 100);

        return { x, y, visible };
      }

      function updateOverlay() {
        if (!measureOn) return;

        const cam = getThreeCam();

        // jei cam nerandam – rodom fallback (iš click coords)
        const s1 = (cam && P1v) ? projectToOverlay(P1v, cam) : S1f;
        const s2 = (cam && P2v) ? projectToOverlay(P2v, cam) : S2f;

        setMarker(p1el, s1);
        setMarker(p2el, s2);
        setLine(s1, s2);

        if (P1v && P2v) {
          const raw = (typeof P1v.distanceTo === "function") ? P1v.distanceTo(P2v) : null;
          const d = (raw !== null) ? (raw * MEASURE_SCALE) : null;

          if (s1 && s2 && s1.visible && s2.visible && d !== null) {
            const mid = { x: (s1.x + s2.x)/2, y: (s1.y + s2.y)/2, visible: true };
            setLabel(mid, `${fmt(d, 2)} ${MEASURE_UNIT}`);
          } else {
            setLabel(null, "");
          }
        } else {
          setLabel(null, "");
        }
      }

      function tick() {
        if (!measureOn) { rafId = null; return; }
        updateOverlay();
        rafId = requestAnimationFrame(tick);
      }

      function startTick() {
        if (rafId !== null) return;
        rafId = requestAnimationFrame(tick);
      }

      function stopTick() {
        if (rafId === null) return;
        cancelAnimationFrame(rafId);
        rafId = null;
      }

      function onMeasureClick(button, mouseCoords) {
        if (!measureOn) return;
        if (button !== 1) return;

        if (!isLoaded || !innerViewer) {
          setStatus("Modelis dar kraunasi… palauk.");
          return;
        }

        let isect = null;
        try {
          isect = innerViewer.GetMeshIntersectionUnderMouse(OVNS.IntersectionMode.MeshAndLine, mouseCoords);
        } catch (e) {
          setStatus("Nepavyko atlikti picking (GetMeshIntersectionUnderMouse).\n" + (e && e.message ? e.message : String(e)));
          return;
        }

        if (!isect || !isect.point) {
          setStatus("Nepataikei ant modelio. Bandyk spustelėti ant geometrijos.");
          return;
        }

        // 3D taškas
        const pt = (typeof isect.point.clone === "function") ? isect.point.clone() : isect.point;

        // fallback 2D coords (visada veikia)
        const sc = { x: mouseCoords.x, y: mouseCoords.y, visible: true };

        if (!P1v) {
          P1v = pt;
          S1f = sc;
          updateOverlay();
          setStatus(
            "Matavimas: pasirinktas 1 taškas.\n" +
            `P1: X=${fmt(P1v.x)} Y=${fmt(P1v.y)} Z=${fmt(P1v.z)}\n` +
            "Dabar spausk 2 tašką."
          );
          return;
        }

        if (!P2v) {
          P2v = pt;
          S2f = sc;
          updateOverlay();

          const raw = (typeof P1v.distanceTo === "function") ? P1v.distanceTo(P2v) : null;
          const d = (raw !== null) ? (raw * MEASURE_SCALE) : null;

          setStatus(
            "Matavimas: parinkti 2 taškai.\n" +
            (d !== null ? `Atstumas: ${fmt(d, 2)} ${MEASURE_UNIT}\n\n` : "") +
            `P1: X=${fmt(P1v.x)} Y=${fmt(P1v.y)} Z=${fmt(P1v.z)}\n` +
            `P2: X=${fmt(P2v.x)} Y=${fmt(P2v.y)} Z=${fmt(P2v.z)}\n\n` +
            "\"Išvalyti\" – naujam matavimui. ESC – išjungti matavimą."
          );
          return;
        }

        // 3-ias click -> pradėti iš naujo
        clearMeasure(true);
        P1v = pt;
        S1f = sc;
        updateOverlay();
        setStatus(
          "Matavimas: pasirinktas 1 taškas.\n" +
          `P1: X=${fmt(P1v.x)} Y=${fmt(P1v.y)} Z=${fmt(P1v.z)}\n` +
          "Dabar spausk 2 tašką."
        );
      }

      try {
        embedded = new OVNS.EmbeddedViewer(host, {
          backgroundColor : new OVNS.RGBAColor(11, 18, 32, 255),
          defaultColor    : new OVNS.RGBColor(200, 200, 200),
          onModelLoaded: () => {
            isLoaded = true;
            if (measureOn) {
              setStatus("Matavimas: spausk 1 tašką ant modelio, tada 2 tašką.\nESC – išjungti. \"Išvalyti\" – nuvalyti.");
            } else {
              setStatus("", false);
            }
          },
          onModelLoadFailed: () => {
            setStatus("Nepavyko užkrauti modelio.\nPatikrink /static/pozicijos/o3dv/ext/occt-import-js/ (worker/wasm) ir ar STEP failas pasiekiamas.");
          }
        });

        embedded.LoadModelFromUrlList([STEP_MODEL_URL]);

        innerViewer = embedded.GetViewer();
        navigation = innerViewer.navigation;

        // išsaugom buvusį click handlerį (jei yra)
        const prevClick = navigation.onMouseClick;

        navigation.SetMouseClickHandler((button, mouseCoords) => {
          if (!measureOn) {
            if (typeof prevClick === "function") prevClick(button, mouseCoords);
            return;
          }
          onMeasureClick(button, mouseCoords);
        });

        window.addEventListener('resize', () => {
          try { embedded.Resize(); } catch (e) {}
          if (measureOn) updateOverlay();
        });

        document.getElementById('btnMeasure').addEventListener('click', () => {
          setMeasureMode(!measureOn);
        });
        document.getElementById('btnClear').addEventListener('click', () => {
          clearMeasure(true);
        });

        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape' && measureOn) {
            setMeasureMode(false);
          }
        });

        setMeasureMode(false);
      } catch (e) {
        setStatus("Klaida inicijuojant 3D peržiūrą:\n" + (e && e.message ? e.message : String(e)));
      }
    });
  </script>
</head>

<body>
  <div class="topbar">
    <div class="left">
      <a class="ui-link" href="{% url 'pozicijos:detail' pozicija.id %}">Atgal</a>
    </div>

    <div class="title">
      <div class="main">{{ pozicija.poz_kodas }} – {{ pozicija.poz_pavad|default:"Be pavadinimo" }}</div>
      <div class="sub">{{ brezinys.pavadinimas|default:brezinys.filename }}</div>
    </div>

    <div class="right">
      <button id="btnClear" class="ui-btn" type="button" style="display:none;">Išvalyti</button>
      <button id="btnMeasure" class="ui-btn" type="button">Matuoti</button>
      <a class="ui-link" href="{{ brezinys.failas.url }}" target="_blank" rel="noopener">Atsisiųsti</a>
    </div>
  </div>

  <div id="viewer"></div>

  <!-- Overlay yra BODY lygyje (kad O3DV jo neištrintų) -->
  <div id="measureOverlay">
    <svg id="measureSvg" xmlns="http://www.w3.org/2000/svg">
      <line id="mline" x1="-9999" y1="-9999" x2="-9999" y2="-9999"
            stroke="rgba(147,197,253,.95)" stroke-width="2" />
    </svg>
    <div id="mpt1" class="mpt"></div>
    <div id="mpt2" class="mpt"></div>
    <div id="mlabel" class="mlabel"></div>
  </div>

  <div id="status"></div>
</body>
</html>
