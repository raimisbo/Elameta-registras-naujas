{% load static %}
<!doctype html>
<html lang="lt">
<head>
  <meta charset="utf-8">
  <title>3D peržiūra – {{ brezinys.pavadinimas|default:brezinys.filename }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    html, body { height: 100%; margin: 0; background: #0b1220; color: #e5e7eb; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif; }

    .topbar {
      height: 52px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 12px;
      background: #111827;
      border-bottom: 1px solid rgba(255,255,255,.08);
      box-sizing: border-box;
      gap: 12px;
    }
    .topbar .left, .topbar .right { display:flex; gap:10px; align-items:center; }
    .topbar .title { min-width: 0; text-align: center; flex: 1; }
    .topbar .title .main { font-weight: 600; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .topbar .title .sub  { font-size: 12px; opacity: .8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .ui-btn, .ui-link {
      color: #93c5fd;
      text-decoration: none;
      font-size: 13px;
      border: 1px solid rgba(147,197,253,.35);
      padding: 6px 10px;
      border-radius: 6px;
      white-space: nowrap;
      background: transparent;
      cursor: pointer;
      user-select: none;
    }
    .ui-btn:hover, .ui-link:hover { background: rgba(147,197,253,.08); }
    .ui-btn.is-on {
      background: rgba(147,197,253,.10);
      border-color: rgba(147,197,253,.60);
    }

    #viewer {
      height: calc(100vh - 52px);
      width: 100%;
    }

    #status {
      position: fixed;
      left: 12px;
      bottom: 12px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      max-width: min(820px, calc(100vw - 24px));
      display: none;
      white-space: pre-wrap;
      z-index: 9999;
    }

    /* Overlay (NE viduje #viewer, kad O3DV jo neištrintų) */
    #measureOverlay {
      position: fixed;
      left: 0;
      top: 52px;
      width: 100vw;
      height: calc(100vh - 52px);
      pointer-events: none;
      display: none;
      z-index: 9000;
    }
    #measureSvg {
      position:absolute;
      left:0; top:0;
      width:100%;
      height:100%;
    }
    .mpt {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: rgba(147,197,253,.90);
      border: 2px solid rgba(255,255,255,.80);
      box-shadow: 0 0 0 2px rgba(0,0,0,.25);
      transform: translate(-9999px, -9999px);
    }

    /* Preview taškas (snap indikacija) */
    .mpt.preview {
      width: 12px;
      height: 12px;
      background: rgba(253, 224, 71, .95);
      border-color: rgba(255,255,255,.90);
    }

    .mlabel {
      position:absolute;
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.18);
      color: #e5e7eb;
      transform: translate(-9999px, -9999px);
      white-space: nowrap;
    }

    /* Back hint overlay (kai negalim grįžti be dublio) */
    #backHint {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      box-sizing: border-box;
    }
    #backHint .panel {
      width: min(620px, 100%);
      background: #0b1220;
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 12px;
      padding: 14px 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,.45);
    }
    #backHint .panel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
    }
    #backHint .panel p {
      margin: 0 0 10px 0;
      font-size: 13px;
      opacity: .9;
      line-height: 1.35;
      white-space: pre-wrap;
    }
    #backHint .panel .actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
    }
  </style>

  <script src="{% static 'pozicijos/js/o3dv.min.js' %}"></script>
  <script>
    const STEP_MODEL_URL = "{{ brezinys.failas.url|escapejs }}";
    const BACK_URL = "{% url 'pozicijos:detail' pozicija.id %}";

    // Jei reikia vienetų konversijos:
    // mm -> m: 0.001 ir "m"
    const MEASURE_SCALE = 1.0;
    const MEASURE_UNIT  = "mm";

    // Snap slenksčiai (px overlay koordinatėse).
    const SNAP_VERTEX_PX = 14;
    const SNAP_EDGE_PX   = 10;

    function setStatus(msg, show = true) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.style.display = show ? 'block' : 'none';
    }

    function fmt(n, d=3) {
      if (typeof n !== 'number' || !isFinite(n)) return String(n);
      return n.toFixed(d);
    }

    function isThreeCamera(obj) {
      if (!obj) return false;
      return !!(obj.projectionMatrix && obj.matrixWorldInverse) || !!(obj.isCamera || obj.isPerspectiveCamera || obj.isOrthographicCamera);
    }

    function dist2d(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function showBackHint(text) {
      const wrap = document.getElementById('backHint');
      const msg = document.getElementById('backHintMsg');
      msg.textContent = text;
      wrap.style.display = 'flex';
    }

    function hideBackHint() {
      const wrap = document.getElementById('backHint');
      wrap.style.display = 'none';
    }

    function smartBack() {
      // Jei 3D yra iframe – eiti į top (tas pats tab'as)
      try {
        if (window.top && window.top !== window.self) {
          window.top.location.href = BACK_URL;
          return;
        }
      } catch (e) {}

      // Jei turim opener (t.y. 3D atidaryta taip, kad leidžia grįžti į originalų tab'ą)
      try {
        if (window.opener && !window.opener.closed) {
          // nukreipiam opener į detail ir fokusuojam
          try { window.opener.location.href = BACK_URL; } catch (e) {}
          try { window.opener.focus(); } catch (e) {}

          // bandom uždaryti šitą tab'ą
          try { window.close(); } catch (e) {}

          // Jei uždaryti neleidžia – NEkraunam detail šiame tab'e, kad nesidubliuotų.
          // Parodom aiškų pranešimą, kad šį tab'ą reikia uždaryti rankiniu būdu.
          setTimeout(() => {
            // Jei vis dar esam čia, vadinasi close nepavyko
            showBackHint(
              "Ši 3D peržiūra buvo atidaryta atskirame tab'e.\n" +
              "Naršyklė neleido automatiškai uždaryti tab'o.\n\n" +
              "Uždarykite šį tab'ą (Cmd+W / Ctrl+W), o pozicijos kortelė yra originaliame tab'e."
            );
          }, 120);

          return;
        }
      } catch (e) {}

      // Jei nėra opener: tai dažniausiai reiškia, kad 3D atidaryta su rel=\"noopener\"
      // Tokiu atveju grįžimas į detail šiame tab'e sukurs dublį, todėl to nedarom.
      // Jei istorija turi prieš tai buvusį įrašą – grįžtam back (be dublio).
      if (window.history && window.history.length > 1) {
        window.history.back();
        return;
      }

      // Kitu atveju – pranešam (neperadresuojam į detail, kad nedubliuotų tab'ų).
      showBackHint(
        "Šis tab'as atidarytas be ryšio su pradiniu (window.opener nėra).\n" +
        "Jei atidarote 3D peržiūrą su target=\"_blank\" ir rel=\"noopener\", naršyklė atjungia pradinį tab'ą.\n\n" +
        "Sprendimas: atidarykite 3D tame pačiame tab'e (be target=_blank) arba atidarykite naują tab'ą be noopener.\n" +
        "Dabar – tiesiog uždarykite šį 3D tab'ą (Cmd+W / Ctrl+W)."
      );
    }

    window.addEventListener('load', () => {
      // Back mygtukas veikia net jei viewer nepasileistų
      const backBtn = document.getElementById('btnBack');
      if (backBtn) backBtn.addEventListener('click', smartBack);

      const backHintClose = document.getElementById('backHintClose');
      if (backHintClose) backHintClose.addEventListener('click', hideBackHint);

      const OVNS = window.OV || (typeof OV !== 'undefined' ? OV : null);
      if (!OVNS) { setStatus("O3DV nepasiekiamas: nerastas global OV."); return; }
      if (!OVNS.EmbeddedViewer) { setStatus("O3DV įkeltas, bet nerastas OV.EmbeddedViewer."); return; }
      if (!STEP_MODEL_URL) { setStatus("Tuščias STEP_MODEL_URL (brezinys.failas.url)."); return; }

      const host = document.getElementById('viewer');
      const overlay = document.getElementById('measureOverlay');
      const pprev = document.getElementById('mprev');
      const p1el = document.getElementById('mpt1');
      const p2el = document.getElementById('mpt2');
      const line = document.getElementById('mline');
      const label = document.getElementById('mlabel');

      let embedded = null;
      let innerViewer = null;
      let navigation = null;
      let isLoaded = false;

      // Measure state
      let measureOn = false;
      let P1v = null; // THREE.Vector3
      let P2v = null; // THREE.Vector3
      let P1snap = null; // 'V' | 'E' | 'F'
      let P2snap = null; // 'V' | 'E' | 'F'

      // fallback screen coords
      let S1f = null; // {x,y,visible}
      let S2f = null;

      // Preview snap
      let preview = null; // {snap:'V'|'E'|'F', s:{x,y,visible}}

      let rafId = null;

      // throttling move
      let moveRaf = null;
      let lastMove = null;

      function showOverlay(on) {
        overlay.style.display = on ? 'block' : 'none';
      }

      function setMarker(el, s) {
        if (!s || !s.visible) {
          el.style.transform = 'translate(-9999px, -9999px)';
          return;
        }
        const sz = el.classList.contains('preview') ? 6 : 5;
        el.style.transform = `translate(${s.x}px, ${s.y}px) translate(-${sz}px, -${sz}px)`;
      }

      function setLine(a, b) {
        if (!a || !b || !a.visible || !b.visible) {
          line.setAttribute('x1', '-9999'); line.setAttribute('y1', '-9999');
          line.setAttribute('x2', '-9999'); line.setAttribute('y2', '-9999');
          return;
        }
        line.setAttribute('x1', String(a.x));
        line.setAttribute('y1', String(a.y));
        line.setAttribute('x2', String(b.x));
        line.setAttribute('y2', String(b.y));
      }

      function setLabel(s, text) {
        if (!s || !s.visible) {
          label.style.transform = 'translate(-9999px, -9999px)';
          label.textContent = '';
          return;
        }
        label.textContent = text;
        label.style.transform = `translate(${s.x}px, ${s.y}px) translate(-50%, -120%)`;
      }

      function clearMeasure(keepMode=false) {
        P1v = null; P2v = null;
        P1snap = null; P2snap = null;
        S1f = null; S2f = null;

        preview = null;
        setMarker(pprev, null);

        setMarker(p1el, null);
        setMarker(p2el, null);
        setLine(null, null);
        setLabel(null, "");

        const btnClear = document.getElementById('btnClear');
        btnClear.style.display = (measureOn ? 'inline-block' : 'none');

        if (keepMode && measureOn) {
          setStatus(
            "Matavimas: spausk 1 tašką ant modelio, tada 2 tašką.\n" +
            "Auto-snap: Vertex > Edge > Free.\n" +
            "ESC – išjungti. \"Išvalyti\" – nuvalyti."
          );
        } else if (!measureOn) {
          setStatus("", false);
        }
      }

      function setMeasureMode(on) {
        measureOn = on;

        const btn = document.getElementById('btnMeasure');
        const btnClear = document.getElementById('btnClear');

        btn.classList.toggle('is-on', measureOn);
        btnClear.style.display = measureOn ? 'inline-block' : 'none';

        if (measureOn) {
          showOverlay(true);
          clearMeasure(true);
          startTick();
        } else {
          showOverlay(false);
          clearMeasure(false);
          stopTick();
        }
      }

      function getThreeCam() {
        if (!innerViewer) return null;

        const cands = [];
        try { if (typeof innerViewer.GetCamera === "function") cands.push(innerViewer.GetCamera()); } catch (e) {}
        cands.push(innerViewer.camera);
        cands.push(innerViewer.renderer && innerViewer.renderer.camera);
        cands.push(innerViewer.renderer && innerViewer.renderer.threeCamera);

        for (const c of cands) {
          if (!c) continue;
          if (isThreeCamera(c)) return c;

          if (c.camera && isThreeCamera(c.camera)) return c.camera;
          if (c.threeCamera && isThreeCamera(c.threeCamera)) return c.threeCamera;

          try {
            if (typeof c.GetThreeCamera === "function") {
              const tc = c.GetThreeCamera();
              if (isThreeCamera(tc)) return tc;
            }
          } catch (e) {}
        }
        return null;
      }

      function projectToOverlay(vec3, cam) {
        if (!vec3 || !cam) return null;

        const w = overlay.clientWidth;
        const h = overlay.clientHeight;
        if (!w || !h) return null;

        if (typeof vec3.clone !== "function" || typeof vec3.project !== "function") return null;

        const v = vec3.clone().project(cam);
        const x = (v.x * 0.5 + 0.5) * w;
        const y = (-v.y * 0.5 + 0.5) * h;

        const visible =
          isFinite(x) && isFinite(y) &&
          x >= -100 && x <= (w + 100) &&
          y >= -100 && y <= (h + 100);

        return { x, y, visible };
      }

      function updateOverlay() {
        if (!measureOn) return;

        const cam = getThreeCam();
        const s1 = (cam && P1v) ? projectToOverlay(P1v, cam) : S1f;
        const s2 = (cam && P2v) ? projectToOverlay(P2v, cam) : S2f;

        setMarker(p1el, s1);
        setMarker(p2el, s2);
        setLine(s1, s2);

        if (preview && (!P1v || !P2v)) {
          setMarker(pprev, preview.s);
        } else {
          setMarker(pprev, null);
        }

        if (P1v && P2v) {
          const raw = (typeof P1v.distanceTo === "function") ? P1v.distanceTo(P2v) : null;
          const d = (raw !== null) ? (raw * MEASURE_SCALE) : null;

          if (s1 && s2 && s1.visible && s2.visible && d !== null) {
            const mid = { x: (s1.x + s2.x)/2, y: (s1.y + s2.y)/2, visible: true };
            setLabel(mid, `${fmt(d, 2)} ${MEASURE_UNIT}`);
          } else {
            setLabel(null, "");
          }
        } else {
          setLabel(null, "");
        }
      }

      function tick() {
        if (!measureOn) { rafId = null; return; }
        updateOverlay();
        rafId = requestAnimationFrame(tick);
      }

      function startTick() {
        if (rafId !== null) return;
        rafId = requestAnimationFrame(tick);
      }

      function stopTick() {
        if (rafId === null) return;
        cancelAnimationFrame(rafId);
        rafId = null;
      }

      function normalizeIntersection(rawHit) {
        if (!rawHit) return null;
        let cand = rawHit.intersection || rawHit.hit || rawHit.result || rawHit;
        if (!cand || !cand.point) return null;

        if (cand === rawHit.intersection) {
          const merged = Object.assign({}, cand);
          if (!merged.object && rawHit.object) merged.object = rawHit.object;
          if (!merged.face && rawHit.face) merged.face = rawHit.face;
          if (typeof merged.faceIndex !== 'number' && typeof rawHit.faceIndex === 'number') merged.faceIndex = rawHit.faceIndex;
          if (!merged.point && rawHit.point) merged.point = rawHit.point;
          return merged;
        }
        return cand;
      }

      function getVector3CtorFrom(inter) {
        if (inter && inter.point && inter.point.constructor) return inter.point.constructor;
        const cam = getThreeCam();
        if (cam && cam.position && cam.position.constructor) return cam.position.constructor;
        return null;
      }

      function getTriangleWorldVerts(inter) {
        if (!inter || !inter.object || !inter.object.geometry) return null;

        const obj = inter.object;
        const geom = obj.geometry;

        const posAttr = geom.attributes && geom.attributes.position;
        if (!posAttr) return null;

        const Vector3 = getVector3CtorFrom(inter);
        if (typeof Vector3 !== 'function') return null;

        let ia = null, ib = null, ic = null;

        if (inter.face && typeof inter.face.a === 'number') {
          ia = inter.face.a; ib = inter.face.b; ic = inter.face.c;
        } else if (typeof inter.faceIndex === 'number') {
          if (geom.index && geom.index.array) {
            const idx = geom.index.array;
            const i = inter.faceIndex * 3;
            ia = idx[i]; ib = idx[i+1]; ic = idx[i+2];
          } else {
            const i = inter.faceIndex * 3;
            ia = i; ib = i+1; ic = i+2;
          }
        } else {
          return null;
        }

        try {
          const vA = new Vector3().fromBufferAttribute(posAttr, ia).applyMatrix4(obj.matrixWorld);
          const vB = new Vector3().fromBufferAttribute(posAttr, ib).applyMatrix4(obj.matrixWorld);
          const vC = new Vector3().fromBufferAttribute(posAttr, ic).applyMatrix4(obj.matrixWorld);
          return { vA, vB, vC };
        } catch (e) {
          return null;
        }
      }

      function closestPointOnSegment(p, a, b) {
        if (!p || !a || !b || typeof p.clone !== 'function') return null;

        const ab = b.clone().sub(a);
        const ap = p.clone().sub(a);
        const denom = (typeof ab.lengthSq === 'function') ? ab.lengthSq() : null;
        if (!denom || denom <= 1e-12) return a.clone();

        let t = ap.dot(ab) / denom;
        t = Math.max(0, Math.min(1, t));

        return a.clone().add(ab.multiplyScalar(t));
      }

      function computeSnap(interRaw, mouseCoords) {
        const inter = normalizeIntersection(interRaw);
        if (!inter || !inter.point) return null;

        const cam = getThreeCam();
        const mouse = { x: mouseCoords.x, y: mouseCoords.y };

        if (!cam) {
          const pt = (typeof inter.point.clone === 'function') ? inter.point.clone() : inter.point;
          return { pt, snap: 'F', screenFallback: { x: mouse.x, y: mouse.y, visible: true } };
        }

        const tri = getTriangleWorldVerts(inter);
        if (!tri) {
          const pt = (typeof inter.point.clone === 'function') ? inter.point.clone() : inter.point;
          const s = projectToOverlay(pt, cam);
          return { pt, snap: 'F', screen: s, screenFallback: { x: mouse.x, y: mouse.y, visible: true } };
        }

        const vList = [tri.vA, tri.vB, tri.vC];
        let bestV = null;

        for (const v of vList) {
          const s = projectToOverlay(v, cam);
          if (!s) continue;
          const d = dist2d(s, mouse);
          if (!bestV || d < bestV.d) bestV = { v, s, d };
        }

        if (bestV && bestV.d <= SNAP_VERTEX_PX) {
          return { pt: bestV.v.clone(), snap: 'V', screen: bestV.s, screenFallback: { x: mouse.x, y: mouse.y, visible: true } };
        }

        const p = (typeof inter.point.clone === 'function') ? inter.point.clone() : inter.point;
        const edges = [
          { a: tri.vA, b: tri.vB },
          { a: tri.vB, b: tri.vC },
          { a: tri.vC, b: tri.vA },
        ];

        let bestE = null;
        for (const e of edges) {
          const cp = closestPointOnSegment(p, e.a, e.b);
          if (!cp) continue;
          const s = projectToOverlay(cp, cam);
          if (!s) continue;
          const d = dist2d(s, mouse);
          if (!bestE || d < bestE.d) bestE = { cp, s, d };
        }

        if (bestE && bestE.d <= SNAP_EDGE_PX) {
          return { pt: (typeof bestE.cp.clone === 'function') ? bestE.cp.clone() : bestE.cp, snap: 'E', screen: bestE.s, screenFallback: { x: mouse.x, y: mouse.y, visible: true } };
        }

        const pt = (typeof inter.point.clone === 'function') ? inter.point.clone() : inter.point;
        const s = projectToOverlay(pt, cam);
        return { pt, snap: 'F', screen: s, screenFallback: { x: mouse.x, y: mouse.y, visible: true } };
      }

      function hidePreview() {
        preview = null;
        setMarker(pprev, null);
      }

      function onHostMouseMove(ev) {
        if (!measureOn) return;
        if (!isLoaded || !innerViewer) return;
        if (P1v && P2v) return;

        const rect = overlay.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;

        if (!isFinite(x) || !isFinite(y) || x < 0 || y < 0 || x > rect.width || y > rect.height) {
          hidePreview();
          return;
        }

        lastMove = { x, y };
        if (moveRaf) return;

        moveRaf = requestAnimationFrame(() => {
          moveRaf = null;
          if (!lastMove || !measureOn) return;

          let hit = null;
          try {
            hit = innerViewer.GetMeshIntersectionUnderMouse(OVNS.IntersectionMode.MeshAndLine, lastMove);
          } catch (e) {
            hidePreview();
            return;
          }

          if (!hit || !hit.point) {
            hidePreview();
            return;
          }

          const snap = computeSnap(hit, lastMove);
          if (!snap) {
            hidePreview();
            return;
          }

          const s = snap.screen || snap.screenFallback;
          preview = { snap: snap.snap, s };
          updateOverlay();
        });
      }

      function onMeasureClick(button, mouseCoords) {
        if (!measureOn) return;
        if (button !== 1) return;

        if (!isLoaded || !innerViewer) {
          setStatus("Modelis dar kraunasi… palauk.");
          return;
        }

        let hit = null;
        try {
          hit = innerViewer.GetMeshIntersectionUnderMouse(OVNS.IntersectionMode.MeshAndLine, mouseCoords);
        } catch (e) {
          setStatus("Nepavyko atlikti picking (GetMeshIntersectionUnderMouse).\n" + (e && e.message ? e.message : String(e)));
          return;
        }

        if (!hit || !hit.point) {
          setStatus("Nepataikei ant modelio. Bandyk spustelėti ant geometrijos.");
          return;
        }

        const snap = computeSnap(hit, mouseCoords);
        const pt = (snap && snap.pt) ? snap.pt : (typeof hit.point.clone === "function" ? hit.point.clone() : hit.point);
        const st = (snap && snap.snap) ? snap.snap : 'F';
        const sc = (snap && (snap.screen || snap.screenFallback)) ? (snap.screen || snap.screenFallback) : { x: mouseCoords.x, y: mouseCoords.y, visible: true };

        if (!P1v) {
          P1v = pt; P1snap = st; S1f = sc;
          hidePreview();
          updateOverlay();
          setStatus(
            "Matavimas: pasirinktas 1 taškas.\n" +
            `P1[${P1snap}]: X=${fmt(P1v.x)} Y=${fmt(P1v.y)} Z=${fmt(P1v.z)}\n` +
            "Dabar spausk 2 tašką."
          );
          return;
        }

        if (!P2v) {
          P2v = pt; P2snap = st; S2f = sc;
          hidePreview();
          updateOverlay();

          const raw = (typeof P1v.distanceTo === "function") ? P1v.distanceTo(P2v) : null;
          const d = (raw !== null) ? (raw * MEASURE_SCALE) : null;

          setStatus(
            "Matavimas: parinkti 2 taškai.\n" +
            (d !== null ? `Atstumas: ${fmt(d, 2)} ${MEASURE_UNIT}\n` : "") +
            `P1[${P1snap}]: X=${fmt(P1v.x)} Y=${fmt(P1v.y)} Z=${fmt(P1v.z)}\n` +
            `P2[${P2snap}]: X=${fmt(P2v.x)} Y=${fmt(P2v.y)} Z=${fmt(P2v.z)}\n\n` +
            "\"Išvalyti\" – naujam matavimui. ESC – išjungti matavimą."
          );
          return;
        }

        clearMeasure(true);
        P1v = pt; P1snap = st; S1f = sc;
        hidePreview();
        updateOverlay();
        setStatus(
          "Matavimas: pasirinktas 1 taškas.\n" +
          `P1[${P1snap}]: X=${fmt(P1v.x)} Y=${fmt(P1v.y)} Z=${fmt(P1v.z)}\n` +
          "Dabar spausk 2 tašką."
        );
      }

      try {
        embedded = new OVNS.EmbeddedViewer(host, {
          backgroundColor : new OVNS.RGBAColor(11, 18, 32, 255),
          defaultColor    : new OVNS.RGBColor(200, 200, 200),
          onModelLoaded: () => {
            isLoaded = true;
            if (measureOn) {
              setStatus(
                "Matavimas: spausk 1 tašką ant modelio, tada 2 tašką.\n" +
                "Auto-snap: Vertex > Edge > Free.\n" +
                "ESC – išjungti. \"Išvalyti\" – nuvalyti."
              );
            } else {
              setStatus("", false);
            }
          },
          onModelLoadFailed: () => {
            setStatus("Nepavyko užkrauti modelio.\nPatikrink /static/pozicijos/o3dv/ext/occt-import-js/ (worker/wasm) ir ar STEP failas pasiekiamas.");
          }
        });

        embedded.LoadModelFromUrlList([STEP_MODEL_URL]);

        innerViewer = embedded.GetViewer();
        navigation = innerViewer.navigation;

        const prevClick = navigation.onMouseClick;

        navigation.SetMouseClickHandler((button, mouseCoords) => {
          if (!measureOn) {
            if (typeof prevClick === "function") prevClick(button, mouseCoords);
            return;
          }
          onMeasureClick(button, mouseCoords);
        });

        host.addEventListener('mousemove', onHostMouseMove, { passive: true });
        host.addEventListener('mouseleave', () => { hidePreview(); }, { passive: true });

        window.addEventListener('resize', () => {
          try { embedded.Resize(); } catch (e) {}
          if (measureOn) updateOverlay();
        });

        document.getElementById('btnMeasure').addEventListener('click', () => {
          setMeasureMode(!measureOn);
        });
        document.getElementById('btnClear').addEventListener('click', () => {
          clearMeasure(true);
        });

        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape' && measureOn) {
            setMeasureMode(false);
          }
        });

        setMeasureMode(false);
      } catch (e) {
        setStatus("Klaida inicijuojant 3D peržiūrą:\n" + (e && e.message ? e.message : String(e)));
      }
    });
  </script>
</head>

<body>
  <div class="topbar">
    <div class="left">
      <button id="btnBack" class="ui-btn" type="button">Atgal</button>
    </div>

    <div class="title">
      <div class="main">{{ pozicija.poz_kodas }} – {{ pozicija.poz_pavad|default:"Be pavadinimo" }}</div>
      <div class="sub">{{ brezinys.pavadinimas|default:brezinys.filename }}</div>
    </div>

    <div class="right">
      <button id="btnClear" class="ui-btn" type="button" style="display:none;">Išvalyti</button>
      <button id="btnMeasure" class="ui-btn" type="button">Matuoti</button>
      {# "Atsisiųsti" pašalintas #}
    </div>
  </div>

  <div id="viewer"></div>

  <!-- Overlay yra BODY lygyje (kad O3DV jo neištrintų) -->
  <div id="measureOverlay">
    <svg id="measureSvg" xmlns="http://www.w3.org/2000/svg">
      <line id="mline" x1="-9999" y1="-9999" x2="-9999" y2="-9999"
            stroke="rgba(147,197,253,.95)" stroke-width="2" />
    </svg>

    <!-- Preview snap marker -->
    <div id="mprev" class="mpt preview"></div>

    <div id="mpt1" class="mpt"></div>
    <div id="mpt2" class="mpt"></div>
    <div id="mlabel" class="mlabel"></div>
  </div>

  <div id="status"></div>

  <!-- Back hint (kai negalim grįžti be dublio) -->
  <div id="backHint">
    <div class="panel">
      <h3>Grįžimas</h3>
      <p id="backHintMsg"></p>
      <div class="actions">
        <button id="backHintClose" class="ui-btn" type="button">Gerai</button>
      </div>
    </div>
  </div>
</body>
</html>
